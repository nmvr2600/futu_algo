# 缠论核心概念技术规范

## 1. 基础概念

### 1.1 K 线包含关系处理

- **定义**：当相邻两根 K 线的价格区间存在包含关系时，需要进行合并处理
- **包含关系类型**：
  - 前包含后：前 K 线高点 ≥ 后 K 线高点 且 前 K 线低点 ≤ 后 K 线低点
  - 后包含前：后 K 线高点 ≥ 前 K 线高点 且 后 K 线低点 ≤ 前 K 线低点
- **合并规则**（修正版）：
  - **向上合并**：当合并方向向上时，高点取两根 K 线的最高值，低点取两根 K 线的较高值
  - **向下合并**：当合并方向向下时，高点取两根 K 线的较低值，低点取两根 K 线的最低值
- **处理流程**：
  1. 遍历 K 线序列，识别包含关系
  2. 按照合并方向规则进行 K 线合并
  3. 记录原始 K 线索引映射关系
  4. 验证合并后序列的完整性

### 1.2 分型（Fractal）

- **顶分型**：
  - 中间 K 线高点为三根 K 线中最高
  - 中间 K 线低点为三根 K 线中最高（确保顶分型的相对独立性）
  - 满足分型有效性：相邻两根 K 线不能包含中间 K 线
- **底分型**：
  - 中间 K 线低点为三根 K 线中最低
  - 中间 K 线高点为三根 K 线中最高（确保底分型的相对独立性）
  - 满足分型有效性：相邻两根 K 线不能包含中间 K 线
- **技术要求**：
  - 分型识别必须在合并后的 K 线序列上进行
  - 分型索引对应合并后 K 线的索引位置
  - 相邻分型之间至少间隔 1 根独立 K 线
  - 分型价格必须满足最小波动幅度要求

## 2. 笔（Stroke）

### 2.1 定义

- 笔是由两个不同性质的分型构成的连线
- 必须满足严格的几何和逻辑关系

### 2.2 构建条件

1. **基本要求**：

   - 起点和终点必须是不同性质的分型（顶分型连接底分型，或底分型连接顶分型）
   - 两分型之间至少间隔 1 根独立 K 线（即两个分型之间至少要有1根不包含在任何一个分型中的K线）
   - 两分型之间不能有同性质分型的破坏

2. **有效性检查**：

   - **包含关系检查**：两分型之间的 K 线不能存在包含关系
   - **破坏检查**：两分型之间不能有同向分型的破坏
   - **距离检查**：两分型之间必须有足够的 K 线间隔

3. **笔的连续性**：
   - 笔与笔之间必须首尾相连，不能出现断点
   - 相邻笔的方向必须相反
   - 笔的构建应遵循贪婪原则，优先选择最近的有效分型

### 2.3 技术实现要点

- 笔的索引应对应合并后 K 线的索引
- 笔的构建应保证连续性，不允许出现断笔
- 笔的绘制应使用直线连接，不允许出现折线

## 3. 线段（Segment）

### 3.1 线段的构成

- **数量要求**：线段至少由 3 笔构成，这是形成有效线段的最基本条件
- **方向一致性**：构成线段的所有笔必须具有相同的方向（全部向上或全部向下）
- **连续性要求**：
  - 构成线段的笔必须连续，即相邻笔之间首尾相连
  - 笔之间不能出现方向相反的情况
  - 笔的连接点必须是有效的分型点

### 3.2 线段破坏的精确定义

- **向上线段破坏**：当出现一笔向下的笔，其终点（底分型低点）低于线段中最后一个向上笔的终点（顶分型高点），则构成对向上线段的破坏
- **向下线段破坏**：当出现一笔向上的笔，其终点（顶分型高点）高于线段中最后一个向下笔的终点（底分型低点），则构成对向下线段的破坏
- **破坏确认**：
  - 破坏点必须是有效的分型点
  - 破坏需要后续走势确认，即破坏笔完成后，必须有至少一笔反向的走势延续
  - 破坏发生后，原线段终结，新的反向线段开始构建

### 3.3 线段在趋势分析中的优势

- **过滤噪音**：线段由至少 3 笔构成，相比单笔更能过滤市场短期波动带来的噪音
- **趋势识别**：线段代表了中等强度的市场趋势，比笔更能反映市场的主要方向
- **买卖点判断**：
  - 线段破坏是重要的趋势转折信号
  - 基于线段的买卖点比基于笔的买卖点更可靠，成功率更高
  - 线段级别背驰比笔级别背驰更具操作价值
- **结构清晰**：线段构成了更清晰的市场结构，便于进行中枢识别和走势分析


## 4. 中枢（Central）

### 4.1 定义

- 中枢由连续 3 笔重叠的部分构成
- 中枢有明确的高低点范围

### 4.2 构建条件

1. **重叠要求**：
   - 连续 3 笔中至少有 2 笔同向
   - 这 3 笔的价格区间必须有精确的重叠部分，且重叠部分需要满足缠论的标准定义

2. **中枢级别**：
   - **1 分钟中枢**：由 1 分钟笔构成
   - **5 分钟中枢**：由 5 分钟笔构成
   - **日线中枢**：由日笔构成
   - 高级中枢可由低级中枢递归构成

3. **中枢操作**：
   - **扩张**：价格突破后返回中枢区间
   - **离开**：价格突破中枢区间并远离
   - **扩展**：形成更大级别的中枢
   - **延伸**：当中枢形成后，后续走势在中枢区间内继续震荡，但不突破中枢的高低点边界。延伸过程中至少包含两个同向笔的重叠部分，且不改变原中枢的级别和性质
   - **新生**：当原中枢结束后，新的走势在原中枢区间外形成新的中枢，且与原中枢没有价格重叠区域。新生中枢的形成标志着趋势可能的延续或反转

4. **背驰类型**：
   - **趋势背驰**：发生在趋势走势末端
   - **盘整背驰**：发生在中枢震荡中
   - **区间套背驰**：多级别同时背驰

7. **确认条件**（重要）：
  - **价格确认**：创新高/新低
  - **指标确认**：MACD 面积或 DIF 线背驰
  - **时间确认**：背驰后必须有反向走势确认
  - **级别确认**：必须在对应级别的笔或线段上

8. **扩展规则**：
  - 扩展必须满足严格的几何条件
  - 中枢可以按照特定规则进行扩展

## 5. 背驰（Divergence）

### 5.1 定义

- 价格创新高/新低，但技术指标没有相应创新高/新低
- 背驰是重要的买卖信号

### 5.2 识别条件

1. **价格背驰**：

   - 价格走势与技术指标走势不一致
   - 必须在有效的笔或线段上识别
   - 需要满足价格创新高/新低，但技术指标没有相应创新高/新低

2. **技术指标**：
   - 严格使用 MACD 指标（柱状图面积或 DIF/DEA 线）进行辅助判断
   - 指标计算应在原始 K 线数据上进行
   - 需要结合价格确认、时间确认和级别确认三个要素

### 5.3 技术指标实现方法

使用 Python 实现背驰判断时，核心是比较两段同向走势（如两段连续的向上或向下线段）的极值点与对应 MACD 指标的数值。

#### 1. MACD 指标计算

首先，需要计算 MACD 指标。通常使用 `talib` 库或自定义函数实现：
- **DIF (差离值)**: 短期（如 12 日）EMA - 长期（如 26 日）EMA
- **DEA (讯号线)**: DIF 的 M 日（如 9 日）EMA
- **MACD Histogram (柱状图)**: (DIF - DEA) * 2

#### 2. 背驰判断逻辑

**顶背驰 (Bearish Divergence)**:
- **价格判断**: 当前顶分型的高点 > 前一个顶分型的高点。
- **指标判断**:
    - **DIF/DEA 背驰**: 当前顶分型对应的 DIF/DEA 值 < 前一个顶分型对应的 DIF/DEA 值。
    - **MACD 面积背驰**: 从前一个顶分型到当前顶分型的 MACD 红柱面积总和 < 从更前一个底分型到前一个顶分型的 MACD 红柱面积总和。面积计算通过对区间内的 MACD 柱状图值求和得到。

**底背驰 (Bullish Divergence)**:
- **价格判断**: 当前底分型的低点 < 前一个底分型的低点。
- **指标判断**:
    - **DIF/DEA 背驰**: 当前底分型对应的 DIF/DEA 值 > 前一个底分型对应的 DIF/DEA 值。
    - **MACD 面积背驰**: 从前一个底分型到当前底分型的 MACD 绿柱面积总和 > 从更前一个顶分型到前一个底分型的 MACD 绿柱面积总和。面积计算是对区间内 MACD 柱状图的绝对值求和。

#### 3. Python 实现步骤示例

以下是一个简化的伪代码，用于说明判断线段背驰的步骤：

```python
def check_divergence(segment1, segment2, macd_data):
    """
    检查两个同向线段之间是否存在背驰
    :param segment1: 前一个线段 (e.g., 向上线段)
    :param segment2: 当前线段 (e.g., 向上线段)
    :param macd_data: 包含 DIF, DEA, MACD 值的 DataFrame
    """
    # 假设为顶背驰判断
    if segment2.direction == 'up' and segment1.direction == 'up':
        # 价格创新高
        price_divergence = segment2.high > segment1.high

        # MACD 指标判断 (以DIF为例)
        macd_at_segment1_end = macd_data['DIF'].loc[segment1.end_k_index]
        macd_at_segment2_end = macd_data['DIF'].loc[segment2.end_k_index]
        macd_divergence = macd_at_segment2_end < macd_at_segment1_end

        if price_divergence and macd_divergence:
            return "顶背驰 (Bearish Divergence)"

    # 假设为底背驰判断
    elif segment2.direction == 'down' and segment1.direction == 'down':
        # 价格创新低
        price_divergence = segment2.low < segment1.low

        # MACD 指标判断 (以DIF为例)
        macd_at_segment1_end = macd_data['DIF'].loc[segment1.end_k_index]
        macd_at_segment2_end = macd_data['DIF'].loc[segment2.end_k_index]
        macd_divergence = macd_at_segment2_end > macd_at_segment1_end

        if price_divergence and macd_divergence:
            return "底背驰 (Bullish Divergence)"

    return "无背驰"

# 注意：实际应用中需处理好K线索引与数据对齐，并精确计算MACD面积。
# K线索引对齐方法：在进行包含关系处理后，需要建立原始K线索引与合并后K线索引的映射关系，
# 通过映射表确保分型、笔、线段的索引位置准确对应到原始K线数据。
# MACD面积计算：确定两个相邻反向分型之间的K线区间，对区间内每个K线对应的MACD柱状图值
# 进行累加求和，注意向上走势使用红柱面积（正值），向下走势使用绿柱面积（负值取绝对值）。
```

#### 4. 注意事项
- **数据对齐**: 确保 K 线数据、分型、笔、线段的索引与 MACD 数据的索引严格对齐。
- **级别对应**: 背驰的判断必须在同一级别上进行，例如 5 分钟级别的线段背驰应使用 5 分钟 K 线计算的 MACD 指标。
- **面积计算**: MACD 面积计算需要精确定义区间的起始点和终点，通常是两个相邻的反向分型之间。

## 6. 可视化技术要求

### 6.1 索引映射

- 必须正确处理原始 K 线与合并后 K 线的索引映射关系
- 所有可视化元素（分型、笔、线段、中枢）都必须使用正确的索引位置

### 6.2 绘制规则

1. **K 线绘制**：

   - 使用合并后的 K 线数据
   - 正确映射到图表坐标位置

2. **分型绘制**：

   - 在对应 K 线位置绘制分型标记
   - 使用不同的颜色和形状区分顶分型和底分型

3. **笔绘制**：

   - 使用直线连接两个分型点
   - 保证笔的连续性，不允许断笔
   - 相邻笔必须方向相反

4. **线段绘制**：

   - 强调显示线段的起止点
   - 可使用不同的线型或颜色区分

5. **中枢绘制**：
   - 使用矩形框标识中枢范围
   - 标注中枢的高低点信息
   - 对于延伸中枢，使用虚线边框或特殊颜色标识
   - 对于新生中枢，使用不同的填充颜色或纹理区别于原中枢

### 6.3 数据一致性

- 所有可视化元素必须基于同一套处理后的数据
- 索引映射必须在整个可视化过程中保持一致
- 不同元素之间的逻辑关系必须正确反映

## 7. 算法实现注意事项

### 7.1 数据处理流程

1. 原始 K 线数据获取
2. K 线包含关系处理和合并
3. 分型识别
4. 笔构建
5. 线段构建
6. 中枢识别
7. 背驰识别
8. 可视化绘制

### 7.2 索引管理

- 建立完整的索引映射体系
- 确保各环节数据索引的一致性
- 处理索引边界情况

### 7.3 错误处理

- 建立完善的异常处理机制
- 处理数据不完整或异常情况
- 保证算法的鲁棒性

## 8. 修复记录

### 8.1 2025-07-26 问题修复

1. **K线时间显示问题**：
   - 修复了图表中K线时间轴显示为1970年的问题
   - 确保了日期格式化和索引映射的正确性

2. **K线绘制异常问题**：
   - 修复了使用特定参数(-k 100 -i 15m -p 1mo)时K线显示为4堆的问题
   - 添加了边界检查确保不会超出数据范围

3. **测试套件问题**：
   - 修复了测试文件中的导入错误
   - 解决了配置文件路径问题
   - 确保所有测试都能正常通过

### 8.2 技术实现改进

1. **索引映射机制优化**：
   - 改进了原始K线与合并后K线的索引映射关系
   - 确保可视化元素（分型、笔、线段、中枢）使用正确的索引位置
   - 添加了索引映射验证机制，在每次映射前后验证数量一致性

2. **边界条件处理**：
   - 添加了数据范围检查，防止数组越界访问
   - 增强了对空数据和小数据集的处理能力
   - 完善了数据对齐检查，确保x_dates和df长度一致

3. **时间轴格式化优化**：
   - 根据数据时间范围动态调整日期格式
   - 支持不同时间间隔（日线、小时线、分钟线等）的正确显示

4. **配置文件路径修复**：
   - 修正了全局变量文件中配置文件路径的处理逻辑
   - 确保在不同目录下运行测试时都能正确找到配置文件

### 8.4 2025-07-26 绘图数据源修复

1. **问题描述**：
   - 绘图错误地使用了合并后的K线数据，而不是原始K线数据
   - 导致原始50根K线在图上显示不完整或位置错误
   - 缠论元素虽然正确计算，但映射到错误的K线上

2. **根本原因**：
   - 在`create_comprehensive_chart`方法中直接用`merged_df`替换了原始的`df`用于绘图
   - 违反了"绘图必须基于原始K线，分析基于合并K线"的原则

3. **修复措施**：
   - 修改`create_comprehensive_chart`方法，始终使用原始数据进行绘图
   - 保留`merged_df`仅供缠论分析使用
   - 确保所有缠论元素通过索引映射准确定位到原始K线上

4. **验证结果**：
   - 修复后，原始K线数据完整显示在图表上
   - 缠论元素（分型、笔、线段等）通过索引映射准确定位
   - 所有测试通过，包括用户报告的具体问题场景